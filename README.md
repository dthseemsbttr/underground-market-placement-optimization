Для того, чтобы посчитать, сколько будет складов и где они будут находится, опишем алгоритм их поиска, а также функции, которые будем использовать для этого. 

Алгоритм:

`    `Input:

`        `labels - рёбра графа

`        `time - время, за которое нужно доехать из любого склада в любую точку

`        `markets - уже существующие склады, по умолчанию их нет

`    `Output:

`        `markets - список складов, при котором достигается требуемое время

Если список markets пуст, то задаем на рандом одну вершину из существующих и вносим её в список складов         (оптимально по времени, скорее всего не оптимально будет в итоге по кол-ву складов)

Теперь в списке складов есть хотя бы один склад. Далее запускаем цикл while True: Для каждой станции метро(вершины) находим минимальное из всех расстояний до складов (под расстоянием понимается минимальный путь из точки А в точку Б). После считаем максимальное из всех таких расстояний. Если получили число, меньше чем нужно, прекращаем цикл, если нет, то ставим на вершину, куда дольше всего добираться, новый склад и переходим на след. итерацию цикла

Функцию collect\_nodes будем использовать в дальнейшем при рисовании графа.

В функции collect\_nodes следующие входные параметры: 

- points – список вершин
- highlighted\_nodes – список вершин, которые мы в дальнейшем будем выделять на графе
- color – цвет всех вершин, по умолчанию - синий
- highlighted\_color – цвет, которым будем выделять highlighted\_nodes, по умолчанию - салатовый
- width – радиус вершин, по умолчанию - 25
- highlighted\_width – радиус highlighted\_nodes, по умолчанию - 100

Данная функция выделяет цветом и увеличивает нужные нам вершины, возвращая список в формате [вершина, её цвет, её радиус]

Функция draw\_graph выводит граф. 

Ее входные параметры:

- points – список вершин
- labels – список ребер
- dict\_labels – словарь с ребрами
- highlighted\_nodes – список вершин, которые нужно выделить
- with\_label – если True, то выводятся названия вершин, если False (по умолчанию), то нет
- with\_label\_labels - если True, то выводится вес ребер, если False (по умолчанию), то нет
- node\_color – цвет вершины
- label\_color – цвет, которым будем выводиться подпись вершины

Для начала создаем граф graph. Каждое ребро имеет структуру (Пункт А, Пункт В, длина ребра, его цвет) и мы добавляем ребро, указывая пункты А и В и цвет ребра (там где индекс 2). Далее получаем список вершин с помощью функции collect\_nodes(). Метод kamada\_kawai-layout помогает нам выводить вершины полученного графа на одном и том же месте. Затем каждой вершине и каждому ребру присваем цвет и ширину, используя уже известные значения. И теперь рисуем сам граф. Конструкция if … отвечает за то, нужно ли на графе показывать вес каждого ребра. 

Данная функция рисует нужный нам граф. 

Функция deikstra находит минимальное расстояние между двумя точками.

Входные данные: 

- A – точка, из которой мы будем искать кратчайший путь
- B – точка, в которую мы будем искать кратчайший путь
- Labels – все ребра
- Points – все вершины

Для начала стоит сказать, что функция @lru\_cache нужна, чтобы при повторном запросе с теми же исходными данными, функция не вычисляла ответ заново, а брала его из кеша, а т.к. во время работы алгоритма длины рёбер меняются и новые вершины не добавляются, то и расстояние между двумя вершинами никак не меняется, так что удобно пользоваться такой функцией. 

Данная функция возвращает минимальное расстояние от точки a до точки b.

Функция place\_markets будет создавать список станций метро, где мы будем ставить склады.

Входные данные:

- Points – список вершин
- Labels – список ребер
- Time – время, обозначенное компанией
- Markets – список складов

Как и было описано выше в алгоритме, сначала выбираем первую точку, в которой ставим склад, рандомно. Дальше делаем все также, как и было описано выше: сначала считаем минимальное время от каждой точки до ближайшего из складов. Находим максимальное из таких значений, и, если оно больше time, то ставим в ту точку еще один склад.

Функция возвращает список станций, на которых будут находится склады.

Заранее я создала файл .xlsx, в который выписала все станции метро (за исключением D1, D2 и БКЛ) в формате: Название станции;  Название станции; Время между ними; Цвет ветки. И в самом начала программы эскпортирую его в Юпитер, используя функцию with open. Так я получаю все вершины, ребра и их вес.


Сравнение разных результатов

Для начала выведем сам граф метро. Но с подписями станций он выглядит непонятно и некрасиво, поэтому выведем без них


Оказалось, что первый склад (выбран рандомно) – станция «Лихоборы». Так как программа работает около двух минут, на каждой итерации выводим сообщение с информацией о том, сколько сейчас максимально занимает времени довезти от складов до какой-то станции метро.

**Время, обозначенное компанией = 20 минут**

А теперь выводим сам список складов: Лихоборы, Коммунарка, Алма-Атинская, Пятницкое шоссе, Рассказовка, Некрасовка, Бульвар Дмитрия Донского, Новоясеневская, Медведково, Щелковская, Деловой центр, Планерная, Университет, Кожуховская. 14 складов.

И выделяем их на графе

Теперь пробуем время больше. Время, обозначенное компанией = **40 минут**

Станции, на которых были построены склады - Лихоборы, Коммунарка, Алма-Атинская, Пятницкое шоссе, Рассказовка, Некрасовка, Бульвар Дмитрия Донского, Новоясеневская. 8 складов.

А теперь посмотрим, что будет, если изменить время на меньшее. Время, обозначенное компанией = **10 минут**

Станции, на которых были построены склады - Лихоборы, Коммунарка, Алма-Атинская, Пятницкое шоссе, Рассказовка, Некрасовка, Бульвар Дмитрия Донского, Новоясеневская, Медведково, Щелковская, Деловой центр, Планерная, Университет, Кожуховская, Полежаевская, Нагорная, Крылатское, Ховрино, Мичуринский проспект, Белокаменная, Кантемировская, Алтуфьево, Лефортово, Достоевская, Новые Черёмушки, Рязанский пр-кт, Саларьево, Сокольники, Котельники, Братиславская, Парк Культуры, Аэропорт, Шоссе Энтузиастов, Окская, Алексеевская, Парк культуры, Крымская. 39 складов.


Из всего, сказанного выше, можем сделать один простой вывод: кол-во складов, а значит и скорость работы программы обратно пропорционально зависят от времени, за которое курьер должен доставить товар. Когда мы увеличили время в 2 раза, кол-во складов уменьшилось почти в 2 раза. Когда мы уменьшили время в 2 раза, кол-во складов выросло примерно в 3 раза. 
